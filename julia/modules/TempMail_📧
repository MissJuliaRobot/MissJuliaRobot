from tempmail import TempMail
import time, markdown
from datetime import datetime
from julia import *
from julia.events import register
from pymongo import MongoClient
from telethon import *
from telethon.tl import *
from telethon.tl.types import *
from telegraph import Telegraph

client = MongoClient(MONGO_DB_URI)
db = client["missjuliarobot"]
tmail = db.tempmail
approved_users = db.approved_users

tm = TempMail()
api_host = "privatix-temp-mail-v1.p.rapidapi.com"
api_key = TEMP_MAIL_KEY
tm.set_header(api_host,api_key)

def get_email(id):
    return tmail.find_one({"user": id})

@register(pattern="^/newmail$")
async def _(event):
    if not event.is_private:
       await event.reply("You can only use this service in PM!")
       return
    gmail = tmail.find({})
    for c in gmail:
        if event.sender_id == c["user"]:
           addr = get_email(event.sender_id)
           ttime = addr["time"]
           if not ttime - time.time() > 86400: # 24 hrs
              await event.reply("You have recently created a new email address, wait for 24hrs to change it")
              return
    ttime = time.time()
    email = tm.get_email_address()
    hash = tm.get_hash(email)
    tmail.insert_one({"user": event.sender_id, "time": ttime, "email": email, "hash": hash})
    await event.reply(f"You have successfully registered your account !\nYour temporary email is: {email}")


@register(pattern="^/mymail$")
async def _(event):
    if not event.is_private:
       await event.reply("You can only use this service in PM!")
       return   
    gmail = tmail.find({})
    for c in gmail:
        if event.sender_id == c["user"]:
           addr = get_email(event.sender_id)
           addrs = addr["email"]
           await event.reply(f"Your current email address is:\n{addrs})
           return
        await event.reply("You don't have any email address associated with your account, get one with /newmail")

@register(pattern="^/checkinbox$")
async def _(event):
    if not event.is_private:
       await event.reply("You can only use this service in PM!")
       return   
    gmail = tmail.find({})
    for c in gmail:
        if not event.sender_id == c["user"]:
           await event.reply("You don't have any email address associated with your account, get one with /newmail")
           return
    addr = get_email(event.sender_id)
    email = addr["email"]
    hash = addr["hash"]
    sender = event.sender_id    
    index = 0
    chatid = event.chat_id
    msg = await tbot.send_message(chatid, "Loading ...")
    msgid = msg.id
    await tbot.edit_message(
        chatid,
        msgid,
        "Click on the below button to check your email inbox 👇",
        buttons=[
            [
                Button.inline(
                    "▶️",
                    data=f"startcheckinbox-{sender}|{email}|{hash}|{index}|{chatid}|{msgid}",
                )
            ],
            [Button.inline("❌", data=f"stopcheckinbox-{sender}|{chatid}|{msgid}")],
        ],
    )

@tbot.on(events.CallbackQuery(pattern=r"stopcheckinbox(\-(.*))"))
async def newsstop(event):
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.sender_id):
            pass
        elif event.chat_id == iid and user_id == userss:
            pass
        else:
            return
    tata = event.pattern_match.group(1)
    data = tata.decode()
    meta = data.split("-", 1)[1]
    # print(meta)
    if "|" in meta:
        sender, chatid, msgid = meta.split("|")
    sender = int(sender.strip())
    chatid = int(chatid.strip())
    msgid = int(msgid.strip())
    if not event.sender_id == sender:
        await event.answer("You haven't send that command !")
        return
    await tbot.edit_message(chatid, msgid, "Thanks for using.\n❤️ from Julia !")

@tbot.on(events.CallbackQuery(pattern=r"startcheckinbox(\-(.*))"))
async def paginate_news(event):
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.sender_id):
            pass
        elif event.chat_id == iid and event.sender_id == userss:
            pass
        else:
            return
    tata = event.pattern_match.group(1)
    data = tata.decode()
    meta = data.split("-", 1)[1]
    # print(meta)
    if "|" in meta:
        sender, email, hash index, chatid, msgid = meta.split("|")
    sender = int(sender.strip())
    if not event.sender_id == sender:
        await event.answer("You haven't send that command !")
        return
    email = email.strip()
    hash = hash.strip()
    index = int(index.strip())
    num = index
    chatid = int(chatid.strip())
    msgid = int(msgid.strip())
    mails = tm.get_mailbox(email=email, email_hash=hash)
    for key, value in mails.items():
        if value == "There are no emails yet":
           await tbot.edit_message(chatid, msgid, 'There are no emails yet.')
           return
    header = f"**#{num} **"
    from_mail = mails[int(num)]['mail_from'])
    subject = mails[int(num)]['mail_subject'])
    msg = mails[int(num)]['mail_html'])
    ttime = mails[int(num)]['mail_timestamp']
    timestamp = ttime
    dt_object = datetime.fromtimestamp(timestamp)
    ttime = str(dt_object)

    telegraph = Telegraph()
    telegraph.create_account(short_name='MissJuliaRobot')
    if subject == "":
       subject = "No Subject"

    headers = f"**FROM**: {from_mail}\n**TO**: {email}\n**DATE**: {ttime}\n**MAIL BODY**:\n\n{msg}"   
    nheaders = headers.replace("\n", "<br />")
    final = markdown.markdown(nheaders)
    response = telegraph.create_page(
               subject, 
               html_content=final)
    tlink = 'https://telegra.ph/{}'.format(response['path'])
  
    lastisthis = f"{header}MAIL FROM: {from_mail}" + "\n" + "TO: {email}" + "\n" + f"DATE: `{date}`" 
    await tbot.edit_message(
        chatid,
        msgid,
        lastisthis,
        link_preview=False,
        buttons=[
            [
                Button.url(
                    "Click here to read this mail",
                    url=f"{tlink}",
                ),
            ],
            [
                Button.inline(
                    "◀️",
                    data=f"checkinboxprev-{sender}|{email}|{hash}|{num}|{chatid}|{msgid}",
                ),
                Button.inline("❌", data=f"stopcheckinbox-{sender}|{chatid}|{msgid}"),
                Button.inline(
                    "▶️",
                    data=f"checkinboxnext-{sender}|{email}|{hash}|{num}|{chatid}|{msgid}",
                ),
            ],
            [
                Button.inline(
                    "Refresh 🔁",
                    data=f"refreshinbox-{sender}|{email}|{hash}|{chatid}|{msgid}",
                )
            ],
        ],
    )


########

    await tbot.send_message(event.chat_id, tlink, buttons=[[Button.inline('<', data="checkinboxprev-{event.sender_id}-{email}-{hash}")], [Button.inline('<', data="stopcheckinbox-{event.sender_id}-{email}-{hash}")], [Button.inline('<', data="checkinboxnext-{event.sender_id}-{email}-{hash}")]])
    
    index = 0
    
    timestamp = ttime
    dt_object = datetime.fromtimestamp(timestamp)
    ttime = str(dt_object)

    telegraph = Telegraph()
    telegraph.create_account(short_name='MissJuliaRobot')
    if subject == "":
       subject = "No Subject"

    headers = f"**FROM**: {from_mail}\n**TO**: {email}\n**DATE**: {ttime}\n**MAIL BODY**:\n\n{msg}"   
    nheaders = headers.replace("\n", "<br />")
    final = markdown.markdown(nheaders)
    response = telegraph.create_page(
               subject, 
               html_content=final)
    tlink = 'https://telegra.ph/{}'.format(response['path'])
    await tbot.send_message(event.chat_id, tlink, buttons=[[Button.inline('<', data="checkinboxprev-{event.sender_id}-{email}-{hash}")], [Button.inline('<', data="stopcheckinbox-{event.sender_id}-{email}-{hash}")], [Button.inline('<', data="checkinboxnext-{event.sender_id}-{email}-{hash}")]])

#####


@tbot.on(events.NewMessage(pattern=None))
async def _(event):   
    gmail = tmail.find({})
    for c in gmail:
        if event.sender_id == c["user"]:
           addr = get_email(event.sender_id)
           email = addr["email"]
           hash = addr["hash"]
           

__help__ = """
 - /newemail: Registers your account for a new email address
 - /myaddress: Gives your current email address
 - /checkinbox: Checks the inbox associated with the account for new emails

**NOTE**: Emails received are temporary and they will be deleted after 60 minutes of arrival
"""
